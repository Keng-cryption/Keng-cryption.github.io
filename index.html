<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>ASL Translator with Skeleton</title>
<style>
  body { font-family: Arial; background: #1E2229; color: #fff; text-align: center; padding-top: 20px; }
  canvas { border-radius: 8px; border: 2px solid #333; }
  #prediction { font-size: 2em; margin-top: 10px; color: #00ff99; }
  #fingers { margin-top: 5px; }
  button { font-size: 1.2em; padding: 10px 20px; margin-top: 10px; cursor: pointer; border-radius: 5px; border: none; background-color: #1E7A54; color: #fff; }
  button:hover { background-color: #2C3E50; }
</style>
</head>
<body>
<h1>Live ASL Translation with Skeleton</h1>
<button id="clearBtn">Clear Word</button>
<br><br>
<canvas id="canvas" width="640" height="480"></canvas>
<p id="prediction">Current Word: </p>
<p id="fingers">Finger State: </p>

<script type="module">
import { Hands } from "https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js";
import { drawConnectors, drawLandmarks } from "https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js";

const canvas = document.getElementById("canvas");
const ctx = canvas.getContext("2d");
const predictionEl = document.getElementById("prediction");
const fingersEl = document.getElementById("fingers");
const clearBtn = document.getElementById("clearBtn");

let currentWord = "";
let lastLetter = "";
let lastCheck = 0;
const interval = 1000;

clearBtn.addEventListener("click", ()=>{ currentWord=""; lastLetter=""; });

// Letter definitions
const LETTER_SIGNS = {
  'A':  { thumb: true, fingers: [0,0,0,0] },
  'B':  { thumb: false, fingers: [1,1,1,1] },
  'C':  { thumb: true, fingers: [1,0,0,1] },
  'D':  { thumb: false, fingers: [1,0,0,0] },
  'E':  { thumb: false, fingers: [0,0,0,0] },
  'F':  { thumb: true, fingers: [0,1,1,1] },
  'G':  { thumb: true, fingers: [0,1,1,0] },
  'H':  { thumb: false, fingers: [1,1,0,0] },
  'I':  { thumb: false, fingers: [0,0,0,1] },
  'K':  { thumb: false, fingers: [1,0,1,1] },
  'L':  { thumb: true, fingers: [1,0,0,0] },
  'M':  { thumb: false, fingers: [0,1,1,0] },
  'N':  { thumb: true, fingers: [1,1,1,0] },
  'O':  { thumb: true, fingers: [0,0,1,1] },
  'P':  { thumb: true, fingers: [1,0,1,1] },
  'Q':  { thumb: true, fingers: [0,1,0,0] },
  'R':  { thumb: false, fingers: [1,1,0,1] },
  'S':  { thumb: false, fingers: [0,1,0,1] },
  'T':  { thumb: false, fingers: [0,0,1,0] },
  'U':  { thumb: true, fingers: [1,1,0,1] },
  'V':  { thumb: true, fingers: [1,1,0,0] },
  'W':  { thumb: false, fingers: [1,1,1,0] },
  'Y':  { thumb: true, fingers: [0,0,0,1] },
  ' ':  { thumb: true, fingers: [1,1,1,1] }
};

// Finger utilities
function fingerUp(lm, tip, pip) { return lm[tip].y < lm[pip].y; }
function getFingerStates(lm) {
  return {
    thumb: lm[4].x < lm[3].x,
    index: fingerUp(lm,8,6),
    middle: fingerUp(lm,12,10),
    ring: fingerUp(lm,16,14),
    pinky: fingerUp(lm,20,18)
  };
}
function classifyLetter(f) {
  const thumb = f.thumb;
  const fingers = [f.index,f.middle,f.ring,f.pinky].map(b=>b?1:0);
  for(const [letter, pattern] of Object.entries(LETTER_SIGNS)) {
    if(pattern.thumb === thumb && pattern.fingers.join(",")===fingers.join(",")) return letter;
  }
  return null;
}

// Webcam setup
const video = document.createElement("video");
video.autoplay = true;
video.playsInline = true;

async function initCamera() {
  const stream = await navigator.mediaDevices.getUserMedia({video:true});
  video.srcObject = stream;
  await video.play();
}
await initCamera();

// MediaPipe Hands
const hands = new Hands({
  locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`
});
hands.setOptions({maxNumHands:1,minDetectionConfidence:0.5,minTrackingConfidence:0.5});
hands.onResults(onResults);

async function detectHands() {
  const tmpCanvas = document.createElement("canvas");
  tmpCanvas.width = video.videoWidth;
  tmpCanvas.height = video.videoHeight;
  const tmpCtx = tmpCanvas.getContext("2d");

  async function loop() {
    tmpCtx.drawImage(video,0,0,tmpCanvas.width,tmpCanvas.height);
    await hands.send({image: tmpCanvas});
    requestAnimationFrame(loop);
  }
  loop();
}

// Draw skeleton & update prediction
function onResults(results) {
  ctx.clearRect(0,0,canvas.width,canvas.height);
  ctx.drawImage(video,0,0,canvas.width,canvas.height);

  if(results.multiHandLandmarks && results.multiHandLandmarks.length>0){
    const lm = results.multiHandLandmarks[0];
    drawConnectors(ctx, lm, Hands.HAND_CONNECTIONS, {color:"#00FF00", lineWidth:3});
    drawLandmarks(ctx, lm, {color:"#FF0000", lineWidth:2});

    const fingers = getFingerStates(lm);
    const now = Date.now();
    if(now - lastCheck > interval){
      lastCheck = now;
      const letter = classifyLetter(fingers);
      if(letter && letter!==lastLetter){
        currentWord += letter;
        lastLetter = letter;
      } else if(!letter){ lastLetter=""; }
    }

    fingersEl.textContent = "Finger State: "+[fingers.thumb,fingers.index,fingers.middle,fingers.ring,fingers.pinky].map(b=>b?1:0).join(",");
    predictionEl.textContent = "Current Word: "+currentWord;
  }
}

detectHands();
</script>
</body>
</html>
